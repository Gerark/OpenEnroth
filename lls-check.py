# lls acronym stands for Lua Language Server
# This script expects four parameters: 
# python lls-check.py [LLS-PATH] [SCRIPTS-FOLDER] [LOG-OUTPUT-FOLDER-PATH] [LLS-CONFIGURATION-PATH]

# LLS-PATH - The path where the LLS executable is located
# SCRIPTS-FOLDER - location where all the scripts that we want to check are located
# LOG-OUTPUT-FOLDER-PATH - the lls final log will be created at this path
# LLS-CONFIGURATION-PATH - location of the configuration file for lls

# The operations executed by this script are:
# 1. Remove the existing lua language server log file
# 2. Ask lua-language-server executable to perform a diagnosis. It will generate a new log file
# 3. Open the check.json log file and communicate potential errors

import json
import sys
import os
import subprocess

def print_lls(message):
    print(f"[Lua Language Server]: {message}")

def main():
    if len(sys.argv) != 5:
        print_lls("Wrong number of arguments passed to lls-check.py")
        return 1

    check_level = "Warning"
    lua_language_server_exe_path = sys.argv[1]
    scripts_folder = sys.argv[2]
    log_output = sys.argv[3]
    configuration_path = sys.argv[4]
    log_file = log_output + "/check.json" # The file generated by lls is named check.json and cannot be customized.

    # lls doesn't create a log file if there are no errors. To prevent false positives, we need to remove the previous log file.
    print_lls("Removing old log file...")
    if os.path.exists(log_file):
        os.remove(log_file)

    print_lls("Running Diagnostics...")
    result = subprocess.run([
        lua_language_server_exe_path,
        f"--check={scripts_folder}",
        f"--checklevel={check_level}",
        f"--logpath={log_output}",
        f"--configpath={configuration_path}"
        ],
        stdout=subprocess.PIPE,
        text=True
    )

    # Show whatever lls wrote to the stdout
    print_lls(result.stdout)
    print_lls("Diagnostics Completed.")

    # If the log file does not exists it means there are no errors
    if os.path.exists(log_file):
        print_lls("Opening Log File.")
        data = open_log_file(log_file)
        if data == None:
            return 1
        # New LLS version produces json file with empty list if there are no errors
        if len(data) == 0:
            return 0

        print_lls(f"Parsing {len(data.items())} Lua Files containing issues...")
        files_with_errors = parse_log(data)
        if len(files_with_errors) > 0:
            print_errors(files_with_errors)
            return 1
    
    return 0

# Open the log file. Returns the internal data
def open_log_file(log_file_path):
    try:
        with open(log_file_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print_lls(f"Can't find log file: {log_file_path}")
        return None
    except json.JSONDecodeError:
        print_lls(f"Invalid JSON log format: {log_file_path}")
        return None

def severity_to_string(severity):
    if severity == 1: return "error"
    elif severity == 2: return "warning"
    elif severity == 3: return "info"
    elif severity == 4: return "debug"
    elif severity == 5: return "trace"
    return "Unknown"

def parse_log(data):
    files_with_errors = []
    for file, logs in data.items():
        errors = []
        for log in logs:
            line = log['range']['start']['line'] + 1
            character = log['range']['start']['character'] + 1
            severity = log['severity']
            message = log['message']
            code = log['code']
            
            message = f"({line},{character}): [{severity_to_string(severity)}] {message} [{code}]"
            errors.append(message)
        
        if len(errors) > 0:
            files_with_errors.append({
                "filename": file,
                "errors": errors
            })

    return files_with_errors

def print_errors(files_with_errors):
    for file_info in files_with_errors:
        errors = file_info["errors"]
        errors_count = len(errors)
        error_word = 'errors' if errors_count > 1 else "error"
        print_lls(f"{errors_count} {error_word} at file: {file_info['filename']}")
        for error in errors:
            print_lls(f" {error}")

result = main()
print_lls(f"{'Found some errors!' if result != 0 else 'All Good!'}")
if result != 0:
    sys.exit(result)
